%YAML 1.2
---

# This is based on the Rust syntax-file included with Sublime Text.

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

# http://www.sublimetext.com/docs/3/syntax.html
name: Kongruent
scope: source.kong

file_extensions:
  - kong

first_line_match: |-
  (?xi:
    ^ \s* // .*? -\*- .*? \brust\b .*? -\*-  # editorconfig
  )

variables:
  identifier: '(?:(?:[[:alpha:]][_[:alnum:]]*|_[_[:alnum:]]+)\b)' # include a word boundary at the end to ensure all possible characters are consumed, to prevent catastrophic backtracking
  escaped_byte: '\\(x\h{2}|n|r|t|0|"|''|\\)'
  escaped_char: '\\(x\h{2}|n|r|t|0|"|''|\\|u\{\h{1,6}\})'
  int_suffixes: 'i8|i16|i32|i64|i128|isize|u8|u16|u32|u64|u128|usize'
  support_type: \b(Copy|Send|Sized|Sync|Drop|Fun|FunMut|FunOnce|Box|ToOwned|Clone|PartialEq|PartialOrd|Eq|Ord|AsRef|AsMut|Into|From|Default|Iterator|Extend|IntoIterator|DoubleEndedIterator|ExactSizeIterator|Option|Some|None|Result|Ok|Err|SliceConcatExt|String|ToString|Vec)\b
contexts:
  main:
    - include: statements

  prototype:
    # Macro metavariables. Ideally we would do this as a with_prototype,
    # however then we run into infinite recursion. It needs to be a prototype
    # since macro_rules! allows constructing new code, thus the metavariables
    # can be inserted in just about any position in the syntax.
    - match: '\${{identifier}}'
      scope: variable.other.kong

  else-pop:
    - match: (?=\S)
      pop: true

  pop-immediately:
    - match: ''
      pop: true

  statements:

    - match: '(''{{identifier}})\s*(:)'
      captures:
        1: entity.name.label.kong
        2: punctuation.separator.kong
    - match: '''{{identifier}}(?!\'')\b'
      scope: storage.modifier.lifetime.kong

    - match: '\b(?:(pub)\s+)?\b(mod)\s+({{identifier}})\b'
      captures:
        1: storage.modifier.kong
        2: storage.type.module.kong
        3: entity.name.module.kong
      push:
        - meta_scope: meta.module.kong
        - match: ';'
          scope: punctuation.terminator.kong
          set: after-operator
        - include: statements-block

    - match: '\b({{identifier}})\s*(=)\s*(?=\|)'
      captures:
        1: entity.name.function.kong
        2: keyword.operator.kong
      push: closure

    - match: '\b(?:(pub)\s+)?\b(fun)\s+(?={{identifier}})'
      scope: meta.function.kong
      captures:
        1: storage.modifier.kong
        2: storage.type.function.kong
      push: fun-definition

    - match: '\b(?:(pub)\s+)?(struct)\s+'
      scope: meta.struct.kong
      captures:
        1: storage.modifier.kong
        2: storage.type.struct.kong
      push: struct-identifier

    - match: '\b(?:(pub)\s+)?(type)\s+({{identifier}})\b'
      captures:
        1: storage.modifier.kong
        2: storage.type.type.kong
        3: entity.name.type.kong

    - match: '\b(?:(pub)\s+)?(trait)\s+({{identifier}})\b'
      captures:
        1: storage.modifier.kong
        2: storage.type.trait.kong
        3: entity.name.trait.kong
      push:
        - meta_scope: meta.trait.kong
        - include: statements-block

    - match: '\bimpl\b'
      scope: storage.type.impl.kong
      push: impl-definition

    - match: '\b(?:(pub)\s+)?(enum)\s+({{identifier}})\b'
      captures:
        1: storage.modifier.kong
        2: storage.type.enum.kong
        3: entity.name.enum.kong
      push:
        - meta_scope: meta.enum.kong
        - include: statements-block

    - match: \b(var|const|static)\b
      scope: storage.type.kong

    - match: \*const\b
      scope: storage.type.kong

    - match: \bfun\b
      scope: storage.type.function.kong

    - match: \bmod\b
      scope: storage.type.module.kong

    - match: \bstruct\b
      scope: storage.type.struct.kong

    - match: \bimpl\b
      scope: storage.type.impl.kong

    - match: \benum\b
      scope: storage.type.enum.kong

    - match: \btype\b
      scope: storage.type.type.kong

    - match: \btrait\b
      scope: storage.type.trait.kong

    - match: \b(mut|pub|unsafe|move|ref)\b
      scope: storage.modifier.kong

    - match: \*mut\b
      scope: storage.modifier.kong

    - match: \b(crate|extern|use|where)\b
      scope: keyword.other.kong

    - match: \b(break|else|for|if|loop|match|while|continue)\b
      scope: keyword.control.kong

    - match: \breturn\b
      scope: keyword.control.kong
      push: after-operator

    - match: \b(as|in|box)\b
      scope: keyword.operator.kong

    - match: \b(virtual|proc|alignof|become|offsetof|priv|pure|sizeof|typeof|unsized|yield|do|abstract|final|override|macro)\b
      scope: invalid.illegal.kong

    - match: \b(true|false)\b
      scope: constant.language.kong

    - include: type

    - match: '\b(macro_rules!)\s+([[:alpha:]_][[:alnum:]_]*)\b'
      captures:
        1: support.function.kong
        2: entity.name.macro.kong
      push: macro-block

    - include: comments
    - include: strings
    - include: chars

    - match: '\b[[:lower:]_][[:lower:][:digit:]_]*(?=\()'
      scope: support.function.kong

    - match: '\b((?:format|print|println|eprint|eprintln)!)\s*(\()'
      captures:
        1: support.macro.kong
        2: meta.group.kong punctuation.section.group.begin.kong
      push:
        - meta_content_scope: meta.group.kong
        - include: comments
        - include: format-string
        - include: format-raw-string
        - match: '(?=\S)'
          set: group-tail

    - match: '\b((?:write|writeln)!)\s*(\()'
      captures:
        1: support.macro.kong
        2: meta.group.kong punctuation.section.group.begin.kong
      push:
        - meta_content_scope: meta.group.kong
        - include: comments
        - match: ','
          set:
            - meta_content_scope: meta.group.kong
            - include: format-string
            - include: format-raw-string
            - match: '(?=\S)'
              set: group-tail

    - match: '\b[[:lower:]_][[:lower:][:digit:]_]*!(?=\s*(\(|\{|\[))'
      scope: support.macro.kong

    - match: '{{support_type}}'
      scope: support.type.kong

    - include: basic-identifiers

    - include: attributes

    - include: numbers

    - match: '(?=\{)'
      push: block

    - match: '(?=\()'
      push: group

    - match: '\['
      scope: punctuation.section.group.begin.kong
      push:
        - meta_scope: meta.group.kong
        - match: '\]'
          scope: punctuation.section.group.end.kong
          pop: true
        - match: ';'
          scope: punctuation.separator.kong
        - include: statements

    - include: return-type

    # Making this an operator helps visually break up large
    # match blocks containing just enums
    - match: '=>'
      scope: keyword.operator.kong
      push: after-operator

    - include: operators

    - match: ';'
      scope: punctuation.terminator.kong
      push: after-operator

    - match: '[:,]'
      scope: punctuation.separator.kong
      push: after-operator

    - match: '\.'
      scope: punctuation.accessor.dot.kong

  operators:
    - match: \.{2,3}
      scope: keyword.operator.range.kong
    - match: '(?:[-+%/*^&|]|<<|>>)='
      scope: keyword.operator.assignment.kong
    - match: '[!<>=]=|[<>]'
      scope: keyword.operator.comparison.kong
    - match: '='
      scope: keyword.operator.assignment.kong
      push: after-operator
    - match: '&&|\|\||!'
      scope: keyword.operator.logical.kong
    - match: '[-+%/*]'
      scope: keyword.operator.arithmetic.kong
    - match: '[&|^]|<<|>>'
      scope: keyword.operator.bitwise.kong
    - match: '[@~?$#'']'
      scope: keyword.operator.kong
    - match: '\b_\b'
      scope: keyword.operator.kong


  attributes:
    - match: '(#!?)(\[)'
      captures:
        1: punctuation.definition.annotation.kong
        2: punctuation.section.group.begin.kong
      push:
        - meta_scope: meta.annotation.kong
        - match: '({{identifier}})(\()'
          captures:
            1: variable.annotation.kong
            2: meta.annotation.parameters.kong meta.group.kong punctuation.section.group.begin.kong
          push:
            - meta_content_scope: meta.annotation.parameters.kong meta.group.kong
            - match: \)
              scope: meta.annotation.parameters.kong meta.group.kong punctuation.section.group.end.kong
              pop: true
            - include: attribute-call
        - match: '({{identifier}})'
          scope: variable.annotation.kong
        - match: '='
          scope: keyword.operator.kong
        - match: '\]'
          scope: punctuation.section.group.end.kong
          pop: true
        - match: '[ \t]+'
        - include: strings

  attribute-call:
    - match: \)
      scope: meta.function-call.kong meta.group.kong punctuation.section.group.end.kong
      pop: true
    - match: '({{identifier}})(\()'
      scope: meta.function-call.kong
      captures:
        1: variable.function.kong
        2: meta.group.kong punctuation.section.group.begin.kong
      push:
        - meta_content_scope: meta.function-call.kong
        - include: attribute-call
    - match: ','
      scope: punctuation.separator.kong
    - match: '='
      scope: keyword.operator.kong
    - include: strings

  block:
    - match: '\}'
      scope: meta.block.kong punctuation.section.block.end.kong
      pop: true
    - match: '\{'
      scope: punctuation.section.block.begin.kong
      push: [block-body, try-closure]

  block-body:
    - meta_scope: meta.block.kong
    - match: '(?=\})'
      pop: true
    - include: statements

  group:
    - match: '\)'
      scope: meta.group.kong punctuation.section.group.end.kong
      pop: true
    - match: '\('
      scope: punctuation.section.group.begin.kong
      push: [group-body, try-closure]

  group-body:
    - meta_scope: meta.group.kong
    - match: '(?=\))'
      pop: true
    - include: statements

  group-tail:
    - meta_scope: meta.group.kong
    - match: '\)'
      scope: punctuation.section.group.end.kong
      pop: true
    - include: statements

  after-operator:
    - match: '(?=<)'
      set: generic-angles
    - include: try-closure

  try-closure:
    - match: '\s*(?=\|)'
      set: closure
    # Exit the context if we didn't find a closure
    - match: '(?=\S)'
      pop: true

  return-type:
    - match: '->'
      scope: punctuation.separator.kong
      push:
        - meta_scope: meta.function.return-type.kong
        - match: '(?=\s*\{|\bwhere\b)'
          pop: true
        - match: '(?=<)'
          push: generic-angles
        - include: type-any-identifier
        - match: '{{identifier}}'
        # Escape for incomplete expression
        - match: '(?=\S)'
          pop: true

  closure:
    - meta_content_scope: meta.function.closure.kong
    - match: '\|'
      scope: punctuation.section.parameters.begin.kong
      set: [closure-return, closure-parameters]

  closure-parameters:
    - meta_scope: meta.function.parameters.kong
    # If the user has just typed a |, exit the params
    # scope as soon as we hit something that it not a
    # valid part so the whole rest of the document isn't
    # highlighted using the params scope
    - match: '(?=[};)\]\n])'
      pop: true
    - match: ','
      scope: punctuation.separator.kong
    - match: '\('
      scope: meta.group.kong punctuation.section.group.begin.kong
      push:
        - meta_content_scope: meta.group.kong
        - match: '\)'
          scope: meta.group.kong punctuation.section.group.end.kong
          pop: true
        - match: ','
          scope: punctuation.separator.kong
        - match: '({{identifier}})'
          scope: variable.parameter.kong
    - match: '(:)\s*(\()'
      captures:
        1: punctuation.separator.kong
        2: meta.group.kong punctuation.section.group.begin.kong
      push:
        - meta_content_scope: meta.group.kong
        - match: '\)'
          scope: meta.group.kong punctuation.section.group.end.kong
          pop: true
        - match: ','
          scope: punctuation.separator.kong
        - include: type-any-identifier
    - match: '\|'
      scope: punctuation.section.parameters.end.kong
      pop: true
    - match: \bself\b
      scope: variable.parameter.kong
    - match: '({{identifier}})\s*(?:(:(?!:))|(?=\||,))'
      captures:
        1: variable.parameter.kong
        2: punctuation.separator.kong
      push:
        - match: (?=,|\|)
          pop: true
        - include: type-any-identifier
    - match: '&'
      scope: keyword.operator.kong
    - match: \b(mut|ref)\b
      scope: storage.modifier.kong
    - match: '''{{identifier}}(?!\'')\b'
      scope: storage.modifier.lifetime.kong

  closure-return:
    - meta_content_scope: meta.function.closure.kong
    - include: return-type
    - match: (?=\S)
      set: closure-body

  closure-body:
    - match: '(?=\{)'
      set: closure-explicit-body
    - match: (?=\S)
      set:
        - meta_scope: meta.function.closure.kong
        - match: '(?=[};)\]\n])'
          pop: true
        - include: statements

  closure-explicit-body:
    - meta_scope: meta.function.closure.kong
    - include: block

  type:
    - match: (?:{{support_type}}|{{identifier}})(?=<)
      captures:
        1: support.type.kong
      push: generic-angles
    - match: \b(Self|i8|i16|i32|i64|i128|isize|u8|u16|u32|u64|u128|usize|f32|f64|float2|float3|float4|bool|char|str)\b
      scope: storage.type.kong

  generic-angles:
    - meta_scope: meta.generic.kong
    - include: comments
    - match: '->'
      scope: punctuation.separator.generic.kong
      push: generic-angles-contents
    - match: '>'
      scope: punctuation.definition.generic.end.kong
      pop: true
    - match: '<'
      scope: punctuation.definition.generic.begin.kong
      push: generic-angles-contents
    # Alert the user of a broken generic construct
    - match: '\S'
      scope: invalid.illegal.kong
      pop: true

  generic-angles-contents:
    - include: comments
    - match: \bextern\b
      scope: keyword.other.kong
      push:
        - include: strings
        - match: '(?=\S)'
          pop: true
    - match: '(?=>|[^ \t\n\$=<_+''(),&:\[\]*[:alnum:]])'
      pop: true
    - match: '<'
      scope: punctuation.definition.generic.begin.kong
      push:
        - match: '>'
          scope: punctuation.definition.generic.begin.kong
          pop: true
        - include: generic-angles-contents
    - match: '\['
      scope: punctuation.section.group.begin.kong
      push:
        - meta_scope: meta.group.kong
        - match: '\]'
          scope: punctuation.section.group.end.kong
          pop: true
        - match: ';'
          scope: punctuation.separator.kong
          set:
            - match: '\]'
              scope: punctuation.section.group.end.kong
              pop: true
            - include: constant-integer-expression
            - match: '(?=\S)'
              pop: true
        - include: generic-angles-contents
    - include: type-any-identifier
    - match: '{{support_type}}'
      scope: support.type.kong
    - match: ':'
      scope: punctuation.separator.kong
    - match: '\+'
      scope: keyword.operator.kong
    - match: '\bas\b'
      scope: keyword.operator.kong

  constant-integer-expression:
    - include: integers
    - match: \(
      scope: punctuation.section.group.begin.kong
      push:
        - meta_scope: meta.group.kong
        - match: \)
          scope: punctuation.section.group.end.kong
          pop: true
        - include: constant-integer-expression
    - match: '{{identifier}}'
      scope: variable.other.constant.kong
    - match: '::'
      scope: punctuation.accessor.double-colon.kong
    - match: '[-+%/*]'
      scope: keyword.operator.arithmetic.kong

  type-any-identifier:
    - match: '&'
      scope: keyword.operator.kong
    - match: \bref\b
      scope: storage.modifier.kong
    - match: (?:\b|\*)(?:mut|const)\b
      scope: storage.modifier.kong
    - match: \b(fun)\b(\()
      captures:
        1: storage.type.function.kong
        2: meta.group.kong punctuation.section.group.begin.kong
      push:
        - meta_content_scope: meta.group.kong
        - match: \)
          scope: meta.group.kong punctuation.section.group.end.kong
          set:
            - include: return-type
            - match: '(?=\S)'
              pop: true
        - include: type-any-identifier
    - match: '''{{identifier}}(?!\'')\b'
      scope: storage.modifier.lifetime.kong
    - match: '\b([[:upper:]]|_*[[:upper:]][[:alnum:]_]*[[:lower:]][[:alnum:]_]*)\b(::)'
      scope: meta.path.kong storage.type.kong
      captures:
        1: storage.type.kong
        2: punctuation.accessor.kong
    - match: '{{identifier}}(::)'
      scope: meta.path.kong
      captures:
        1: punctuation.accessor.kong
    - match: '(::)(?={{identifier}})'
      scope: meta.path.kong punctuation.accessor.kong
    - match: '(?=<)'
      push: generic-angles
    - match: '\('
      scope: punctuation.section.group.begin.kong
      push:
        - match: '\)'
          scope: punctuation.section.group.end.kong
          pop: true
        - include: type-any-identifier
    - include: type
    - match: '\b_\b'
      scope: keyword.operator.kong

  struct-identifier:
    - match: '{{identifier}}(?=<)'
      scope: entity.name.struct.kong
      set:
        - meta_scope: meta.struct.kong meta.generic.kong
        - match: '(?=<)'
          push: generic-angles
        - match: ''
          set: struct-body
    - match: '{{identifier}}'
      scope: entity.name.struct.kong
      set: struct-body

  struct-body:
    - meta_scope: meta.struct.kong
    - include: comments
    - match: '(?=\()'
      set: struct-tuple
    - match: '(?=\{)'
      set: struct-classic
    - match: '(?=;)'
      pop: true

  struct-tuple:
    - meta_scope: meta.struct.kong
    - match: '\)'
      scope: punctuation.section.group.end.kong
      pop: true
    - match: '\('
      scope: punctuation.section.group.begin.kong
      # Ensure that we end the tuple at the next ) to
      # prevent odd highlighting as the user is typing
      with_prototype:
        - match: '(?=\))'
          pop: true
      push:
        - meta_scope: meta.group.kong
        - include: comments
        - include: type-any-identifier

  struct-classic:
    - meta_scope: meta.struct.kong
    - match: '\}'
      scope: meta.block.kong punctuation.section.block.end.kong
      pop: true
    - match: '\{'
      scope: punctuation.section.block.begin.kong
      push:
        - meta_scope: meta.block.kong
        - match: '(?=\})'
          pop: true
        - include: comments
        - include: attributes
        - match: \b(pub)\b(?:(\()(crate)(\)))?
          captures:
            1: storage.modifier.kong
            2: punctuation.definition.modifier-scope.begin.kong
            3: storage.modifier.kong
            4: punctuation.definition.modifier-scope.end.kong
        - match: '{{identifier}}(?=\s*:)'
          scope: variable.other.member.kong
          push:
            - match: ',|(?=\})'
              pop: true
            - include: comments
            - match: ':'
              scope: punctuation.separator.type.kong
            - include: type-any-identifier

  macro-block:
    # This meta scope requires some juggling
    - meta_scope: meta.macro.kong
    - match: \{
      scope: meta.block.kong punctuation.section.block.begin.kong
      set:
        - meta_content_scope: meta.macro.kong meta.block.kong
        - match: \}
          scope: meta.macro.kong meta.block.kong punctuation.section.block.end.kong
          pop: true
        - include: macro-block-contents
    - match: \[
      scope: meta.group.kong punctuation.section.group.begin.kong
      set:
        - meta_content_scope: meta.macro.kong meta.group.kong
        - match: \]
          scope: meta.macro.kong meta.group.kong punctuation.section.group.end.kong
          pop: true
        - include: macro-block-contents
    - match: \(
      scope: meta.group.kong punctuation.section.group.begin.kong
      set:
        - meta_content_scope: meta.macro.kong meta.group.kong
        - match: \)
          scope: meta.macro.kong meta.group.kong punctuation.section.group.end.kong
          pop: true
        - include: macro-block-contents
    - include: else-pop

  macro-block-contents:
    - include: comments
    - match: (?=\()
      push:
        - macro-terminator
        - macro-body
        - macro-match-operator
        - macro-matcher

  macro-matcher:
    - match: \(
      scope: punctuation.section.group.begin.kong
      set:
        - meta_include_prototype: false
        - meta_scope: meta.group.macro-matcher.kong
        - match: \)
          scope: punctuation.section.group.end.kong
          pop: true
        - match: ((\$)\()
          captures:
            1: punctuation.section.group.begin.kong
            2: keyword.operator.kong
          push:
            - meta_scope: meta.group.kong
            - meta_include_prototype: false
            - match: (\))(?:\s*[^*+]?\s*([*+]))?
              captures:
                1: punctuation.section.group.end.kong
                2: keyword.operator.kong
              pop: true
            - include: macro-metavariable
        - include: macro-metavariable

  macro-match-operator:
    - match: =>
      scope: keyword.operator.kong
      pop: true
    - include: else-pop

  macro-body:
    - match: \{
      scope: punctuation.section.block.begin.kong
      set:
        - meta_scope: meta.block.macro-body.kong
        - match: \}
          scope: punctuation.section.block.end.kong
          pop: true
        - include: statements
    - match: \(
      scope: punctuation.section.group.begin.kong
      set:
        - meta_scope: meta.group.macro-body.kong
        - match: \)
          scope: punctuation.section.group.end.kong
          pop: true
        - include: statements
    - match: \[
      scope: punctuation.section.group.begin.kong
      set:
        - meta_scope: meta.group.macro-body.kong
        - match: \]
          scope: punctuation.section.group.end.kong
          pop: true
        - include: statements
    - include: else-pop

  macro-metavariable:
    - match: '(\${{identifier}})(:)(ident|path|expr|ty|pat|stmt|block|item|meta|tt)'
      captures:
        1: variable.parameter.macro.kong
        2: punctuation.separator.kong
        3: storage.type.kong

  macro-terminator:
    - match: ;|,
      scope: punctuation.terminator.macro-matcher.kong
    - include: else-pop

  impl-definition:
    - meta_scope: meta.impl.kong
    - include: comments
    - match: '(?=<)'
      set: [impl-for, impl-generic]
    - match: (?=\S)
      set: impl-for

  impl-generic:
    - meta_scope: meta.impl.kong
    - match: '(?=<)'
      push: generic-angles
    - match: ''
      pop: true

  impl-for:
    - match: '(?=\s*(?:::|{{identifier}}|\$|<)+(<.*?>)?\s+for\s+)'
      set:
        - meta_scope: meta.impl.kong
        - include: comments
        - match: \bfor\b
          scope: keyword.other.kong
          set: impl-identifier
        - include: type-any-identifier
    - match: ''
      set: impl-identifier

  impl-identifier:
    - meta_content_scope: meta.impl.kong
    - include: comments
    - match: '(?=\{)'
      set: impl-body
    - match: '(?=\bwhere\b)'
      set: impl-where
    - match: '{{identifier}}'
      scope: entity.name.impl.kong
    - match: '(?=<)'
      push: generic-angles
    - match: '&'
      scope: keyword.operator.kong
    - match: \b(mut|ref)\b
      scope: storage.modifier.kong
    - match: '''{{identifier}}(?!\'')\b'
      scope: storage.modifier.lifetime.kong

  impl-where:
    - meta_scope: meta.impl.kong
    - include: comments
    - match: '(?=\{)'
      set: impl-body
    - match: \bfor\b
      scope: keyword.other.kong
    - match: \bwhere\b
      scope: keyword.other.kong
    - include: type-any-identifier
    - match: ':'
      scope: punctuation.separator.kong

  impl-body:
    - meta_scope: meta.impl.kong
    - include: statements-block

  fun-definition:
    - meta_scope: meta.function.kong
    - include: comments
    - match: '{{identifier}}'
      scope: entity.name.function.kong
      set: fun-generic

  fun-generic:
    - include: comments
    - match: '(?=<)'
      push: generic-angles
    - match: '(?=\()'
      set: fun-parameters
    # Escape for incomplete expression
    - match: '(?=\S)'
      pop: true

  fun-parameters:
    - meta_scope: meta.function.kong
    - include: comments
    - match: '\)'
      scope: meta.function.parameters.kong punctuation.section.parameters.end.kong
      set: fun-return
    - match: '\('
      scope: punctuation.section.parameters.begin.kong
      push:
        - meta_scope: meta.function.parameters.kong
        - include: comments
        - match: '(?=\))'
          pop: true
        - match: '\('
          scope: meta.group.kong punctuation.section.group.begin.kong
          push:
            - meta_content_scope: meta.group.kong
            - match: '\)'
              scope: meta.group.kong punctuation.section.group.end.kong
              pop: true
            - match: ','
              scope: punctuation.separator.kong
            - match: '{{identifier}}'
              scope: variable.parameter.kong
        - match: '(:)\s*(\()'
          captures:
            1: punctuation.separator.kong
            2: meta.group.kong punctuation.section.group.begin.kong
          push:
            - meta_content_scope: meta.group.kong
            - match: '\)'
              scope: meta.group.kong punctuation.section.group.end.kong
              pop: true
            - match: ','
              scope: punctuation.separator.kong
            - include: type-any-identifier
        - match: \bself\b
          scope: variable.parameter.kong
        - match: '({{identifier}})\s*(:(?!:))'
          captures:
            1: variable.parameter.kong
            2: punctuation.separator.kong
        - include: type-any-identifier

  fun-return:
    - meta_scope: meta.function.kong
    - include: comments
    - match: '(?=\{)'
      set: fun-body
    - match: '(?=\bwhere\b)'
      set: fun-where
    - include: return-type
    # Escape for incomplete expression
    - match: '(?=\S)'
      pop: true

  fun-where:
    - meta_scope: meta.function.kong
    - include: comments
    - match: '(?=\{)'
      set: fun-body
    - match: \bfor\b
      scope: keyword.other.kong
    - match: \bwhere\b
      scope: keyword.other.kong
    - include: type-any-identifier
    - match: ':'
      scope: punctuation.separator.kong

  fun-body:
    - meta_scope: meta.function.kong
    - match: '\}'
      scope: meta.block.kong punctuation.section.block.end.kong
      pop: true
    - match: '\{'
      scope: punctuation.section.block.begin.kong
      push:
        - meta_scope: meta.block.kong
        - match: '(?=\})'
          pop: true
        - include: statements

  statements-block:
    - include: comments
    - match: '\}'
      scope: meta.block.kong punctuation.section.block.end.kong
      pop: true
    - match: '\{'
      scope: punctuation.section.block.begin.kong
      push: [block-body, try-closure]

  comments:
    - include: block-comments
    - match: "//[!/]"
      scope: punctuation.definition.comment.kong
      push:
        - meta_scope: comment.line.documentation.kong
        - match: $\n?
          pop: true
    - match: //
      scope: punctuation.definition.comment.kong
      push:
        - meta_scope: comment.line.double-slash.kong
        - match: $\n?
          pop: true

  block-comments:
    - match: '/\*[!\*][^\*/]'
      scope: punctuation.definition.comment.kong
      push:
        - meta_scope: comment.block.documentation.kong
        - match: \*/
          scope: punctuation.definition.comment.kong
          pop: true
        - match: ^\s*(\*)(?!/)
          captures:
            1: punctuation.definition.comment.kong
        - include: block-comments
    - match: /\*
      scope: punctuation.definition.comment.kong
      push:
        - meta_scope: comment.block.kong
        - match: \*/
          scope: punctuation.definition.comment.kong
          pop: true
        - include: block-comments

  strings:
    - include: byte-string
    - include: raw-byte-string
    - include: string
    - include: raw-string

  chars:
    - include: char
    - include: byte

  escaped-byte:
    - match: '{{escaped_byte}}'
      scope: constant.character.escape.kong

  byte:
    - match: "(b)(')(?=([^'\\\\]|{{escaped_byte}})')"
      captures:
        1: storage.type.string.kong
        2: punctuation.definition.string.begin.kong
      push:
        - meta_include_prototype: false
        - meta_scope: string.quoted.single.kong
        - match: \'
          scope: punctuation.definition.string.end.kong
          pop: true
        - include: escaped-byte

  byte-string:
    - match: '(b)(")'
      captures:
        1: storage.type.string.kong
        2: punctuation.definition.string.begin.kong
      push:
        - meta_include_prototype: false
        - meta_scope: string.quoted.double.kong
        - match: '"'
          scope: punctuation.definition.string.end.kong
          pop: true
        - include: escaped-byte

  raw-byte-string:
    - match: (br)(#*)"
      captures:
        1: storage.type.string.kong
        2: punctuation.definition.string.begin.kong
      push:
        - meta_include_prototype: false
        - meta_scope: string.quoted.double.raw.kong
        - match: '"\2'
          scope: punctuation.definition.string.end.kong
          pop: true

  escaped-char:
    - match: '{{escaped_char}}'
      scope: constant.character.escape.kong

  char:
    - match: "'(?=([^'\\\\]|{{escaped_char}})')"
      scope: punctuation.definition.string.begin.kong
      push:
        - meta_scope: string.quoted.single.kong
        - match: \'
          scope: punctuation.definition.string.end.kong
          pop: true
        - include: escaped-char

  string:
    - match: '"'
      scope: punctuation.definition.string.begin.kong
      push:
        - meta_include_prototype: false
        - meta_scope: string.quoted.double.kong
        - match: '"'
          scope: punctuation.definition.string.end.kong
          pop: true
        - include: escaped-char
        - match: '(\\)$'
          scope: punctuation.separator.continuation.line.kong

  raw-string:
    - match: (r)((#*)")
      captures:
        1: storage.type.string.kong
        2: punctuation.definition.string.begin.kong
      push:
        - meta_include_prototype: false
        - meta_scope: string.quoted.double.raw.kong
        - match: '"\3'
          scope: punctuation.definition.string.end.kong
          pop: true

  format-string:
    - match: '"'
      scope: punctuation.definition.string.begin.kong
      push:
        - meta_include_prototype: false
        - meta_scope: string.quoted.double.kong
        - match: '"'
          scope: punctuation.definition.string.end.kong
          pop: true
        - include: escaped-char
        - include: format-escapes
        - match: '(\\)$'
          scope: punctuation.separator.continuation.line.kong

  format-raw-string:
    - match: (r)(#*)"
      captures:
        1: storage.type.string.kong
        2: punctuation.definition.string.begin.kong
      push:
        - meta_include_prototype: false
        - meta_scope: string.quoted.double.raw.kong
        - match: '"\2'
          scope: punctuation.definition.string.end.kong
          pop: true
        - include: format-escapes

  format-escapes:
    - match: '\{\{|\}\}'
      scope: constant.character.escape.kong
    - match: |-
        (?x)                      # Spec from http://doc.kong-lang.org/std/fmt/
        \{
          (\d+|{{identifier}})?
          (
            :                     # format_spec delimiter
            (.?[<>^])?            # [[fill]align]
            [+-]?                 # [sign]
            \#?                   # ['#']
            0?                    # [0]
            (\d\$?)?              # [width]
            (\.(\d\$?|\*)?)?      # ['.' precision]
            (\?|{{identifier}})?  # [type]
          )?
        \}
      scope: constant.other.placeholder.kong

  numbers:
    - include: floats
    - include: integers

  floats:
    - match: '\b((?:\d[\d_]*)?\d\.)(\d[\d_]*(?:[eE][+-]?[\d_]*\d[\d_]*)?)(f32|f64|float2|float3|float4)?'
      captures:
        1: constant.numeric.float.kong
        2: constant.numeric.float.kong
        3: storage.type.numeric.kong
    - match: '\b((?:\d[\d_]*)?\d\.)(?!\.)'
      scope: constant.numeric.float.kong
    - match: '\b(\d[\d_]*)(f32|f64)\b'
      captures:
        1: constant.numeric.float.kong
        2: storage.type.numeric.kong

  integers:
    - match: '\b(\d[\d_]*)({{int_suffixes}})?\b'
      captures:
        1: constant.numeric.integer.decimal.kong
        2: storage.type.numeric.kong
    - match: '\b(0x[\h_]*\h[\h_]*)({{int_suffixes}})?\b'
      captures:
        1: constant.numeric.integer.hexadecimal.kong
        2: storage.type.numeric.kong
    - match: '\b(0o[0-7_]*[0-7][0-7_]*)({{int_suffixes}})?\b'
      captures:
        1: constant.numeric.integer.octal.kong
        2: storage.type.numeric.kong
    - match: '\b(0b[0-1_]*[0-1][0-1_]*)({{int_suffixes}})?\b'
      captures:
        1: constant.numeric.integer.binary.kong
        2: storage.type.numeric.kong

  basic-identifiers:
    - match: '\b([[:upper:]_][[:upper:][:digit:]_]+)\b'
      scope: constant.other.kong
    - match: '\b(c_[[:lower:][:digit:]_]+|[[:lower:]_][[:lower:][:digit:]_]*_t)\b'
      scope: storage.type.kong
    - match: '(?={{identifier}}::)'
      push:
        - meta_scope: meta.path.kong
        - include: no-path-identifiers
        - match: '::'
          scope: punctuation.accessor.kong
          set: no-type-names
    - match: '{{identifier}}(::)'
      scope: meta.path.kong
      captures:
        1: punctuation.accessor.kong
      push: no-type-names
    - match: '(::)(?={{identifier}})'
      scope: meta.path.kong punctuation.accessor.kong
      push: no-type-names
    - include: no-path-identifiers

  no-path-identifiers:
    - match: \b(self)\b
      scope: variable.language.kong
    - match: \b(super)\b
      scope: keyword.other.kong

  no-type-names:
      # This push state prevents highlighting basic types like
      # i32, etc when following ::
      - include: comments
      - include: basic-identifiers
      - match: '{{identifier}}'
      - match: '(?=<)'
        push: generic-angles
      - match: ''
        pop: true
